ORM (Обєктно-реліаційне відображення) - технологія яка звязує бази данних із ООП.
## Models
---
В `django` для створення баз данних чи получення якихось даних не потрібно використовувати SQL тому що як ви вже зрозуміли він використовує технологію ORM.

Якщо для прикладу то створеня простох таблиці для `User` з полями `name` та `email` потрібно написати такий код в файлі `models.py`:
```python
from django.db import models

class User(models.Model):
	name = models.CharField()
	email = models.CharField()
```
>[!info] На замітку
>`Django` автоматично створює поле `id` в каждій табличці.

Зразу виникає питання як получити якісь данні із таблиці? Та доволі просто як за приклад можна взяти получення всіх данних із цієї таблиці:
```python
User.objects.all() -> QuerySet
```

Так ви правильно зрозуміли що у класі `models.Model` створюється менеджер який управляє вашою таблицею. І також він повертає не просто список а QuerySet якщо грубо говоря то це лінивий список.
## Fields
---
Через ці Fields задаються типи полям наприклад `text`, `data`, тощо. І всі ці "Типи данних" є в модулі `models`, ну давайте розгляне більше полів:
- `models.CharField(max_length=255)` - Це поле для зберігання символів.
- `models.IntegerField()` - Це поле для зберігання цілих чисел.
- `models.DataField()` - Поле для дати.
- `models.DataTimeField()` - Поле для дати та часу.
- `models.TextField()` - Поле для тексу але різниця між `CharField` то що в `TextField` можна записувати безліміт тексту.
- `models.ForeignKey()` - Поле для many to one.
- `models.OneToOneField()` - Поле для one to one.
- `models.ManyToManyField()` - Поле для many to many.

Все це одні із популярних полів які використовуються в таблицях.
## Аргументи в Полях
---
Давайте поговоримо про те які всежтаки є аргументи в цих полях і як модифікувати їх. Ну що почнемо із самого простого як обмежити довжину текста в `CharField`:
```python
name = CharField(max_length=255)
```

У вас може виникнути ситуація що деколи це поле може бути не заповненим но якщо створити той же `CharField` і передати пусту строчку або нічого то буде помилка. То що всежтаки робити?:
```python
name = CharField(max_length=255, null=True)
```

А от наступний аргумент може бути похожим на `null` але він відповідає за заповненість поля але вже як більш в коді пайтона а не в базі данних:
```python
name = CharField(max_length=255, blank=True)
```

Хм а якщо вам потрібно зразу якесь значення, наприклад як аватарки в соціальних мережах точніше коли ви створюєте аккаунт то там буде стояти аватарка профіля noname так ви можете зробити і тут, якщо коротше то дефолтне значення при створення таблиці вставляти:
```python
name = CharField(max_length=255, null=True, default="Noname")
```

Також можна зробити вибір між декільками елементами як приклад вибір гендера на сайтах:
```python
DEFAULT_VALUES = [
	('Noname', "Hes man"), # перший елемент це значення другий це опис значення
	("Puso", "Xui")
]

name = CharField(max_length=255, choices=DAFAULT_VALUES, null=True)
```
>[!error] Обовязково запамятаєте
>якщо ви задаєте аргумент `choices` то обовязково має бути і `null=True`.

От припустимо ви дали якесь дуже оригінальне імя поля як `qwerty` і не знаєте тепер за що це поле відповідає, є вирішення пишіть описи для полів:
```python
name = CharField("This field for name user", max_length=255)
```

Ну і як можна забути про час, от наприклад уявім що ви десь працюєте і вам дали завдання зробити таблицю із `username` та часом коли створився аккаунт то зробіть якось отак:
```python
class User(models.Model):
	username = models.CharField(max_length=20)
	created = models.DataTimeField(auto_now=True)
```

Ви могли замітити що ми використали якийсь `auto_now=True` але ми могли використати `default=datatime.datatime.now()` тільки це буде некоректно працювати.

А тепер поговоримо про то який ви унікальний, але всежтаки тут не про те просто зробім поле яке такеж унікальне і не може бути копії в таблиці:
```python
username = models.CharField(max_length=20, unique=True) # unique - унікальність
```
## Migrations
---
Після того як ви напишите певний код в `models.py` то ви можете замітити що якщо запустити сервер то ніякі таблиці не добавляться, чому спитаєте ви, а я відповім томущо у базу данних не було збережено змін. але як їх зберегти?
```python
python manage.py makemigrations
```

Все ви створили міграцію. Ну міграція це якраз створення спеціальних файлів міграцій. Ви можете замітити добавлення в папці `migrations`. Так але коли ви всерівно запустите сервер то нічого не змінется хоть ви і створили відповідні файли. То ви забули їх застосувати:
```python
python manage.py migrate
```

От вже тепер ви зможете запустити сервер і перевірити що ця таблиця була створена.
## Методи добавляння даних у таблицю
---
В цілому є два основні добавляння данних в таблицю як за приклад возьмемо цей код:
```python
class User(models.Model):
	username = models.CharField(max_length=20)
	created = models.DataTimeField(auto_now=True)
```

1) Перший метою це використовувати дефолтний менеджер класу `Model` а тоїсть `objects`:
```python
User.objects.create(username="G.Muha")
```

2) От другий чучуть відрізняється там ми будемо використовувати чудовий метод `.save()`:
```python
user = User("G.Muha") # Або спочатку ініціалізувати а потім user.username = "G.Muha"
user.save()
```

Саме інтересне в другому способі що до поки ви не напишите метод `.save()` то `id` цього обєкту буде дорівнювати `None` і це буде означати що його просто навсього нема в таблиці.
## Відношення в таблицях
---
В `Django` три типи відношення в таблицях:
- Many-to-Many
- Many-to-One
- One-to-One

Каждий із видів корисний і використовується регулярно ну давайте розглянемо приклади і більш конкретно про ці відношення.

1) Many-to-Many
```python
class Genre(models.Model):
	genr = models.CharField(max_length=100)

class Film(models.Model):
	title = models.CharField(max_length=255)
	genres = models.ManyToManyField(Genre, related_name="films")
```

Тоїсть ми зробили це відношення і що воно означає? Фільм має багато жанрів но і не один фільм може мати наприклад один жанр `horror` цей жанр може мати два фільма но і ті два фільма мати ще по жанку наприклад `Детектив`.
>[!info] Зверніт увагу
>Поле `ManyToManyField` створює додаткову таблицю для зберігання звязків.

2) One-to-Many
```python
class Company(models.Model):
    name = models.CharField(max_length=30)

class Product(models.Model):
    company = models.ForeignKey(Company, on_delete=models.CASCADE, releted_name="companys")
    name = models.CharField(max_length=30)
    price = models.IntegerField()
```

В цьому випадку в нас є компанія і в неї є багато випущених продуктів тоїсть продукт може мати тільки одну компанію а вона в свою очерідь багато продуктів.

3) One-to-One
```python
class People(models.Model):
	name = models.CharField(max_length=255)
	secondname = models.CharField(max_length=255)
	bestfreind = models.OneToOneField(People)
```

Так ми і написали відношення `One-to-One` вродіби все зрозуміло у `People` може буди тільки один `bestfriend`.

Ще трохи про відношення. Давайте подумаємо логічно що ж відбудеться якщо наприклад в звязку `One-to-One` видалиться одна людина то що робити? для таких случаїв існують різні тактики які потрібно вписувати в аргумент `on_delete`. Давайте розглянемо пару із них:
- **models.CASCADE**: Автоматом видаляє поле якщо одне із відношень було видалено.
- **models.PROTECT**: Просто буде блокувати получення данних видалиної таблиці.
- **models.SET_NULL**: Встановить Null замість видаленої таблиці.
- **models.SET_DEFAULT**: Встановить значення `default` якщо воно було перед цим вказано.
- **models.DO_NOTHING**: Нічого не зробить.